#version 460


#include "bitterli2020.glsl"


vec3 getIllumination(inout RNG rng, vec3 hitPos, vec3 hitDirection) {
	Reservoir r = createReservoir();

	for (uint i = 0; i < renderSettings.candidateCount; ++i) {
		Sample s;
		s.lsp = getRandomLightSourcePoint(rng);
		float inv_sqrt = 1.0 / square_length(hitPos, s.lsp.pos);
		s.weight = s.lsp.lightStrength * inv_sqrt * dot(hitDirection, -s.lsp.normal);
		if (s.weight <= -0.01) continue;

		updateReservoir(r, rng, s, s.weight);
	}

	LightSourcePoint lsp = r.y.lsp;
	vec3 W = (shadowTrace(lsp, hitPos, hitDirection) / r.y.weight) * (1.0 / float(r.M)) * r.w_sum;
	return W;
}


void main() {
	RNG rng = initRNG(gl_LaunchIDEXT);

	RaySendInfo rayInfo = getVisionRay(gl_LaunchIDEXT.xy, gl_LaunchSizeEXT.xy);

	for (int i = 0; i < renderSettings.visionJumpCount; i++) {
		traceRay(rayInfo);

		if (!rayPayload.hit) break;

		uint traceValue = handleHit(rayInfo, rng);

		if (traceValue == DIFFUSE_VALUE) {
			break;
		}
	}

	if (rayPayload.hit) {
		if (rayPayload.lightSource) {
			imageStore(finalImage, ivec2(gl_LaunchIDEXT.xy), vec4(rayPayload.color, 0.0));
		} else {
			vec3 illumination;
			if (renderSettings.usePrimitiveShadowTrace == 0) {
				illumination = getIllumination(rng, rayPayload.pos, rayPayload.normal);
			} else {
				illumination = getIlluminationByShadowtrace(rng, rayPayload.pos, rayPayload.normal, renderSettings.shadowTraceCount);
			}
			imageStore(finalImage, ivec2(gl_LaunchIDEXT.xy), vec4(rayPayload.color * illumination, 0.0));
		}
	} else {
		imageStore(finalImage, ivec2(gl_LaunchIDEXT.xy), vec4(0.0));
	}
}
