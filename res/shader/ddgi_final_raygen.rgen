#version 460

#define RAYGEN_SHADER
#include "ddgi.glsl"


ivec3 baseGridCoord(vec3 X) {
	vec3 probeStartPos = -vec3(renderSettings.singleDirectionProbeCount * renderSettings.betweenProbeDistance);
	return clamp(
		ivec3((X - probeStartPos) / renderSettings.betweenProbeDistance),
		ivec3(0),
		ivec3(2 * renderSettings.singleDirectionProbeCount)
	);
}

vec3 gridCoordToPosition(ivec3 c) {
	vec3 probeStartPos = -vec3(renderSettings.singleDirectionProbeCount * renderSettings.betweenProbeDistance);
	return renderSettings.betweenProbeDistance * vec3(c) + probeStartPos;
}

uint gridCoordToProbeIndex(vec3 probeCoords) {
	uint probeCounts = 2 * renderSettings.singleDirectionProbeCount + 1;
	return uint(probeCoords.x + probeCoords.y * probeCounts + probeCoords.z * probeCounts * probeCounts);
}

vec2 textureCoordFromDirection(vec3 dir, uint probeIndex) {
	float probeSideLength = float(renderSettings.probeSampleSideLength);
	ivec2 fullTextureSize = imageSize(irradianceBuffer);

	vec2 normalizedOctCoord = octEncode(normalize(dir));
	vec2 normalizedOctCoordZeroOne = (normalizedOctCoord + vec2(1.0)) * 0.5;

	float probeWithBorderSide = probeSideLength + 2.0;
	vec2 octCoordNormalizedToTextureDimensions = (normalizedOctCoordZeroOne * probeSideLength) / vec2(fullTextureSize);
	int probesPerRow = (fullTextureSize.x - 2) / int(probeWithBorderSide);

	vec2 probeTopLeftPosition = vec2(
		float(probeIndex % probesPerRow) * probeWithBorderSide,
		float(probeIndex / probesPerRow) * probeWithBorderSide
	) + vec2(2.0);

	vec2 normalizedProbeTopLeftPosition = probeTopLeftPosition / vec2(fullTextureSize);

	return vec2(normalizedProbeTopLeftPosition + octCoordNormalizedToTextureDimensions);
}

vec3 getIrradiance(vec3 originPos, vec3 viewDirection, vec3 hitPos, vec3 hitNormal) {
	vec3 originDirection = -viewDirection;
	ivec3 baseGridCoord = baseGridCoord(hitPos);
	vec3 baseProbePos = gridCoordToPosition(baseGridCoord);
	vec3 alpha = clamp((hitPos - baseProbePos) / renderSettings.betweenProbeDistance, vec3(0.0), vec3(1.0));

	vec3 sumIrradiance = vec3(0.0);
	float sumWeight = 0.0;

	for (uint i = 0; i < 8; ++i) {
		ivec3 offset = ivec3(i, i >> 1, i >> 2) & ivec3(1);
		ivec3 probeGridCoord = clamp(baseGridCoord + offset, ivec3(0), ivec3(2 * renderSettings.singleDirectionProbeCount));
		uint probeIndex = gridCoordToProbeIndex(probeGridCoord);
		vec3 probePos = gridCoordToPosition(probeGridCoord);
		vec3 probeToPoint = hitPos - probePos + (hitNormal + 3.0 * originDirection) * renderSettings.normalBias;
		vec3 probeDirection = normalize(-probeToPoint);

		float weight = 1.0;

		vec3 trueDirectionToProbe = normalize(probePos - hitPos);
		float trueDirectionToProbeWeight = max(0.0001, (dot(trueDirectionToProbe, hitNormal) + 1.0) * 0.5);
		weight *= trueDirectionToProbeWeight * trueDirectionToProbeWeight + 0.2;

		vec2 texCoord = textureCoordFromDirection(-probeDirection, probeIndex);

		float distToProbe = length(probeToPoint);
		vec2 depthTemp = texture(depthSampler, texCoord).xy;
		float depthMean = depthTemp.x;
		float depthVariance = abs(depthMean * depthMean - depthTemp.y);

		float depthMeanDistToProbe = max(distToProbe - depthMean, 0.0);
		float chebyshevWeight = depthVariance / (depthVariance + depthMeanDistToProbe * depthMeanDistToProbe);
		chebyshevWeight = max(pow(chebyshevWeight, 3), 0.0);

		if (distToProbe <= depthMean) weight *= chebyshevWeight;

		weight = max(0.0001, weight);
		vec3 irradianceDirection = hitNormal;
		vec3 probeIrradiance = texture(irradianceSampler, texCoord).xyz;

		float crushThreshold = renderSettings.crushThreshold;
		if (weight < crushThreshold) weight *= weight * weight * (1.0 / (crushThreshold*crushThreshold));

		vec3 trilinear = lerp(vec3(1.0) - alpha, alpha, vec3(offset));
		weight *= trilinear.x * trilinear.y * trilinear.z;

		if (renderSettings.linearBlending == 0) probeIrradiance = sqrt(probeIrradiance);

		sumIrradiance += weight * probeIrradiance;
		sumWeight += weight;
	}

	vec3 netIrradiance = sumIrradiance / sumWeight;
	if (renderSettings.linearBlending == 0) netIrradiance = netIrradiance*netIrradiance;
	netIrradiance *= renderSettings.energyPreservation;

	return 0.5 * PI * netIrradiance;
}


void main() {
	vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
	vec2 inUV = pixelCenter/vec2(gl_LaunchSizeEXT.xy);
	vec2 d = inUV * 2.0 - 1.0;

	vec3 origin = (globalData.viewInverse * vec4(vec3(0), 1)).xyz;
	vec3 target = (globalData.projInverse * vec4(d.x, d.y, 1, 1)).xyz;
	vec3 direction = normalize((globalData.viewInverse * vec4(normalize(target), 0)).xyz);

	uint rayFlags = gl_RayFlagsOpaqueEXT;
	uint cullMask = 0xFF;
	float tmin = 0.001;
	float tmax = 10000.0;

	for (int i = 0; i < renderSettings.visionJumpCount; i++) {
		traceRayEXT(topLevelAS, rayFlags, cullMask, 0, 0, 0, origin, tmin, direction, tmax, 0);

		if (!rayPayload.hit) break;

		float rayHandlingValue = rand(origin + gl_LaunchIDEXT, i, 0);

		if (rayHandlingValue <= rayPayload.diffuseThreshold) {
			break;
		} else if (rayHandlingValue <= rayPayload.reflectThreshold) {
			origin = rayPayload.pos;
			direction = reflect(direction, rayPayload.normal);
		} else if (rayHandlingValue <= rayPayload.transparentThreshold) {
			origin = rayPayload.pos;
			direction = customRefract(direction, rayPayload.normal, rayPayload.refractionIndex);
		}
	}

	if (rayPayload.hit) {
		vec3 modifiedPos = rayPayload.pos + renderSettings.normalBias * rayPayload.normal;
		vec3 color = rayPayload.color * getShade(modifiedPos, rayPayload.normal);
		vec3 irradiance = getIrradiance(origin, direction, modifiedPos, rayPayload.normal);

		imageStore(finalImage, ivec2(gl_LaunchIDEXT.xy), vec4(color + irradiance, 0.0));
	} else {
		imageStore(finalImage, ivec2(gl_LaunchIDEXT.xy), vec4(0.0));
	}
}
