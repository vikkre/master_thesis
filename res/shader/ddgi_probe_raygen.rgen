#version 460

#define RAYGEN_SHADER
#include "ddgi.glsl"


void main() {
	uint surfelIndex = uint(gl_LaunchIDEXT.y) * renderSettings.perProbeRayCount + uint(gl_LaunchIDEXT.x);

	uint se = 2 * renderSettings.singleDirectionProbeCount + 1;
	uint i = uint(gl_LaunchIDEXT.y);

	uint x = (i % se);
	i = (i - x) / se;

	uint y = (i % se);
	i = (i - y) / se;

	uint z = (i % se);
	
	ivec3 prepos = ivec3(x, y, z) - ivec3(renderSettings.singleDirectionProbeCount);
	vec3 origin = renderSettings.betweenProbeDistance * vec3(prepos);
	vec3 direction = sphericalFibonacci(float(gl_LaunchIDEXT.x), float(renderSettings.perProbeRayCount));

	uint rayFlags = gl_RayFlagsOpaqueEXT;
	uint cullMask = 0xFF;
	float tmin = 0.001;
	float tmax = renderSettings.maxProbeRayDistance;

	for (int i = 0; i < renderSettings.visionJumpCount; i++) {
		traceRayEXT(topLevelAS, rayFlags, cullMask, 0, 0, 0, origin, tmin, direction, tmax, 0);

		if (!rayPayload.hit) break;

		float rayHandlingValue = rand(origin + gl_LaunchIDEXT, i, 0);

		if (rayHandlingValue <= rayPayload.diffuseThreshold) {
			break;
		} else if (rayHandlingValue <= rayPayload.reflectThreshold) {
			origin = rayPayload.pos;
			direction = reflect(direction, rayPayload.normal);
		} else if (rayHandlingValue <= rayPayload.transparentThreshold) {
			origin = rayPayload.pos;
			direction = customRefract(direction, rayPayload.normal, rayPayload.refractionIndex);
		}
	}

	surfels.s[surfelIndex].rayDirection = direction;
	
	if (rayPayload.hit) {
		vec3 modifiedPos = rayPayload.pos + renderSettings.normalBias * rayPayload.normal;
		surfels.s[surfelIndex].hitRadiance = rayPayload.color * getShade(modifiedPos, rayPayload.normal);
		surfels.s[surfelIndex].hitDistance = length(origin - modifiedPos);
		surfels.s[surfelIndex].hit = true;
	} else {
		surfels.s[surfelIndex].hitRadiance = vec3(0.0);
		surfels.s[surfelIndex].hitDistance = 0.0;
		surfels.s[surfelIndex].hit = false;
	}
}
