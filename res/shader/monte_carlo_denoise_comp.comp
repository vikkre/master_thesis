#version 460

#define COMPUTE_SHADER
#include "monte_carlo.glsl"


#define KSIZE 7
#define SIGMA 0.8


void main() {
	ivec2 pos = ivec2(gl_GlobalInvocationID.xy);

	// float gauss[KSIZE];
	// float sum = 0.0;
	// for (uint i = 0; i < KSIZE; i++) {
	// 	float a = (float(i) - (float(KSIZE) - 1.0));
	// 	a = a*a;
	// 	float b = (2.0 * SIGMA * SIGMA);
	// 	float r = exp(-a/b);
	// 	gauss[i] = r;
	// 	sum += r;
	// }
	// sum = 1.0/sum;
	// for (uint i = 0; i < KSIZE; i++) {
	// 	gauss[i] *= sum;
	// }

	// vec4 color = vec4(0.0);
	// ivec2 size = imageSize(finalImage);
	// int off = KSIZE / 2;

	// for (int x = -off; x <= off; x++) {
	// 	for (int y = -off; y <= off; y++) {
	// 		ivec2 p = pos + ivec2(x, y);
	// 		if (0 <= p.x && p.x < size.x && 0 <= p.y && p.y < size.y) {
	// 			color += imageLoad(finalImage, p) * gauss[x + off] * gauss[y + off];
	// 		}
	// 	}
	// }

	// ivec2 size = imageSize(finalImage);
	// int off = KSIZE / 2;

	// vec4 colors[KSIZE * KSIZE];
	// float csums[KSIZE * KSIZE];
	// int count = 0;

	// for (int x = -off; x <= off; x++) {
	// 	for (int y = -off; y <= off; y++) {
	// 		ivec2 p = pos + ivec2(x, y);
	// 		if (0 <= p.x && p.x < size.x && 0 <= p.y && p.y < size.y) {
	// 			vec4 color = imageLoad(finalImage, p);
	// 			float csum = max(color.x, max(color.y, color.z));

	// 			colors[count] = color;
	// 			csums[count] = csum;
	// 			count++;
	// 		}
	// 	}
	// }

	// for (uint n = KSIZE * KSIZE; n > 0; n--) {
	// 	for (uint i = 0; i < n; i++) {
	// 		if (csums[i] < csums[i+1]) {
	// 			vec4 tmp_color = colors[i];
	// 			float tmp_csum = csums[i];

	// 			colors[i] = colors[i+1];
	// 			csums[i] = csums[i+1];

	// 			colors[i+1] = tmp_color;
	// 			csums[i+1] = tmp_csum;
	// 		}
	// 	}
	// }

	// vec4 color = colors[count/2];

	vec4 color = imageLoad(finalImage, pos);
	imageStore(denoisedImage, pos, color);
}
