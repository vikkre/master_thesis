#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_scalar_block_layout : enable


#define DEPTH 4
#define ITERATIONS 200
#define DIFFUSE_PART 0.5


struct PointData {
	vec3 pos;
	vec3 color;
};

struct KDData {
	vec3 pos;
	vec3 color;
	uint direction;
	int leftIndex;
	int rightIndex;
};

layout(binding = 3, set = 0) buffer Count {uint c; } count;
layout(binding = 4, set = 0, scalar) buffer XY { PointData d[]; } pointData;
layout(binding = 5, set = 0, scalar) buffer YZ { KDData d[]; } kdData;


KDData getNewKDData(PointData point, uint direction) {
	KDData data;

	data.pos = point.pos;
	data.color = point.color;
	data.direction = direction;

	data.leftIndex = -1;
	data.rightIndex = -1;

	return data;
}

void append(inout KDData entry, int index, PointData point) {
	if (point.pos[entry.direction] < entry.pos[entry.direction]) {
		if (entry.leftIndex == -1) {
			kdData.d[index] = getNewKDData(point, (entry.direction + 1) % 3);
			entry.leftIndex = index;
		}
		// else append(kdData.d[entry.leftIndex], index, point);
	} else {
		if (entry.rightIndex == -1) {
			kdData.d[index] = getNewKDData(point, (entry.direction + 1) % 3);
			entry.rightIndex = index;
		}
		// else append(kdData.d[entry.rightIndex], index, point);
	}
}

void main() {
	kdData.d[0] = getNewKDData(pointData.d[0], 0);

	for (int i = 1; i < count.c; i++) {
		bool inserting = true;
		int	currentIndex = 0;

		for (int u = 0; u < count.c; u++) {
			KDData entry = kdData.d[currentIndex];
			PointData point = pointData.d[i];
			
			if (point.pos[entry.direction] < entry.pos[entry.direction]) {
				if (entry.leftIndex == -1) {
					kdData.d[currentIndex].leftIndex = i;
					kdData.d[i] = getNewKDData(point, (entry.direction + 1) % 3);
					inserting = false;
				} else {
					currentIndex = entry.leftIndex;
				}
			} else {
				if (entry.rightIndex == -1) {
					kdData.d[currentIndex].rightIndex = i;
					kdData.d[i] = getNewKDData(point, (entry.direction + 1) % 3);
					inserting = false;
				} else {
					currentIndex = entry.rightIndex;
				}
			}
		}
	}
}
