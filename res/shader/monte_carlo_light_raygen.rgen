#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_scalar_block_layout : enable


#define PI 3.1415926538

#define DEPTH 4
#define ITERATIONS 200
#define DIFFUSE_PART 0.5


struct PointData {
	vec3 pos;
	vec3 color;
};


layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 2, set = 0, scalar) uniform GlobalData {
	mat4 viewInverse;
	mat4 projInverse;
	mat4 view;
	mat4 proj;
	vec3 backgroundColor;
	vec3 lightPosition;
	uint lightJumpCount;
	uint visionJumpCount;
	float collectionDistance;
	uint rayPerPixelCount;
} globalData;
layout(binding = 3, set = 0) buffer Count {uint count;} c;
layout(binding = 4, set = 0, scalar) buffer XYZ { PointData d[]; } pointData;

struct RayPayload {
	bool miss;
	vec3 pos;
	vec3 normal;
	vec3 color;
	float diffuseThreshold;
	float reflectThreshold;
	float glossyThreshold;
	float transparentThreshold;
};
layout(location = 0) rayPayloadEXT RayPayload rayPayload;

float rand(vec3 co, int i, int v){
	return fract(sin(dot(co, vec3(12.9898, 78.233, 38.4965)) * (v + 1.0) + i) * 43758.5453);
}

vec3 randomNormal(vec3 co, int i, int vStart) {
	float theta = 2.0 * PI * rand(co, i, vStart);
	float u = 2.0 * rand(co, i, vStart+1) - 1.0;
	float suu = sqrt(1 - u*u);

	return vec3(
		suu * cos(theta),
		suu * sin(theta),
		u
	);
}

vec3 randomNormalDirection(vec3 co, int i, int vStart, vec3 normal) {
	vec3 randVec = randomNormal(co, i, vStart);

	if (dot(randVec, normal) < 0.0) {
		randVec *= -1;
	}

	return randVec;
}

void main() {
	vec3 origin = globalData.lightPosition;
	vec3 direction = randomNormal(gl_LaunchIDEXT, 0, 1);

	uint rayFlags = gl_RayFlagsOpaqueEXT;
	uint cullMask = 0xFF;
	float tmin = 0.001;
	float tmax = 10000.0;

	vec3 color = vec3(1.0);

	for (int i = 0; i < globalData.lightJumpCount; i++) {
		traceRayEXT(topLevelAS, rayFlags, cullMask, 0, 0, 0, origin, tmin, direction, tmax, 0);

		if (rayPayload.miss) break;

		color *= rayPayload.color;

		float rayHandlingValue = rand(origin + gl_LaunchIDEXT, i, 0);

		if (rayHandlingValue <= rayPayload.diffuseThreshold) {
			uint index = atomicAdd(c.count, 1);
			pointData.d[index].pos = rayPayload.pos;
			pointData.d[index].color = color;

			origin = rayPayload.pos;
			direction = randomNormalDirection(origin + gl_LaunchIDEXT, i, 1, rayPayload.normal);
		} else if (rayHandlingValue <= rayPayload.reflectThreshold) {
			origin = rayPayload.pos;
			direction = reflect(direction, rayPayload.normal);
		} else if (rayHandlingValue <= rayPayload.glossyThreshold) {
			
		} else if (rayHandlingValue <= rayPayload.transparentThreshold) {
			
		}
	}

	// if (!rayPayload.miss) {
	// 	uint index = atomicAdd(c.count, 1);
	// 	pointData.d[index].pos = rayPayload.pos;
	// 	pointData.d[index].color = color;
	// }
}
