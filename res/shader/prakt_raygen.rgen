#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_scalar_block_layout : enable


#define DEPTH 4
#define ITERATIONS 200
#define DIFFUSE_PART 0.5


layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 0, rgba8) uniform image2D image;
layout(binding = 2, set = 0, scalar) uniform GlobalData {
	mat4 viewInverse;
	mat4 projInverse;
	mat4 view;
	mat4 proj;
	vec3 backgroundColor;
	vec3 lightPosition;
} globalData;

struct RayPayload {
	vec3 color;
	float distance;
	vec3 normal;
	float reflector;
};
layout(location = 0) rayPayloadEXT RayPayload rayPayload;

float rand(vec2 co, int i, int v){
	return fract(sin(dot(co, vec2(12.9898, 78.233)) * v + i) * 43758.5453);
}

void main() {
	const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
	const vec2 inUV = pixelCenter/vec2(gl_LaunchSizeEXT.xy);
	vec2 d = inUV * 2.0 - 1.0;

	vec4 origin = globalData.viewInverse * vec4(vec3(0), 1);
	vec4 target = globalData.projInverse * vec4(d.x, d.y, 1, 1);
	vec4 direction = globalData.viewInverse * vec4(normalize(target.xyz), 0);

	uint rayFlags = gl_RayFlagsOpaqueEXT;
	uint cullMask = 0xFF;
	float tmin = 0.001;
	float tmax = 10000.0;

	vec3 color = vec3(0.0);

	for (int i = 0; i < DEPTH; i++) {
		traceRayEXT(topLevelAS, rayFlags, cullMask, 0, 0, 0, origin.xyz, tmin, direction.xyz, tmax, 0);
		vec3 hitColor = rayPayload.color;

		if (rayPayload.distance < 0.0) {
			color = hitColor;
			break;
		} else if (rayPayload.reflector > 0.5) {
			const vec4 hitPos = origin + direction * rayPayload.distance;
			origin.xyz = hitPos.xyz + rayPayload.normal * 0.001;
			direction.xyz = reflect(direction.xyz, rayPayload.normal);
		} else {
			const vec4 hitPos = origin + direction * rayPayload.distance;
			origin.xyz = hitPos.xyz + rayPayload.normal * 0.001;
			vec3 normal = rayPayload.normal;

			vec3 diffuseColor = vec3(0.0);
			int hits = 0;

			for (int u = 0; u < ITERATIONS; u++) {
				vec3 randomDirection = vec3(
					rand(hitPos.xy, u, 0) * 2.0 - 1.0,
					rand(hitPos.xy, u, 1) * 2.0 - 1.0,
					rand(hitPos.xy, u, 2) * 2.0 - 1.0
				);
				direction.xyz = normalize((randomDirection + normal) * 0.5);

				traceRayEXT(topLevelAS, rayFlags, cullMask, 0, 0, 0, origin.xyz, tmin, direction.xyz, tmax, 0);

				if (rayPayload.reflector < 0.5 && rayPayload.distance >= 0.0) {
					hits++;
					diffuseColor += rayPayload.color;
				}
			}

			diffuseColor /= float(hits);
			diffuseColor.x = clamp(diffuseColor.x, 0, 1);
			diffuseColor.y = clamp(diffuseColor.y, 0, 1);
			diffuseColor.z = clamp(diffuseColor.z, 0, 1);

			color = hitColor + (diffuseColor - hitColor) * DIFFUSE_PART;
			color.x = clamp(color.x, 0, hitColor.x);
			color.y = clamp(color.y, 0, hitColor.y);
			color.z = clamp(color.z, 0, hitColor.z);

			break;
		}
	}

	imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(color, 0.0));
}
